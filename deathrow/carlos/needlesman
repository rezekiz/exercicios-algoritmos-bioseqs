'''
    score_subst: Esta função recebe dois caracteres x1 e x2 e um valor g representando o espaço (gap).
    A função retorna a pontuação da substituição de um pelo outro. Se algum dos caracteres for '-', ela retorna o valor de gap g.
    Se x1 é igual a x2, retorna 2; caso contrário, retorna -1.
    '''

def score_subst(x1, x2, g):
    if '-' in (x1, x2):
        return g
    return 2 if x1 == x2 else -1

    '''
    iniciar_matrizes: Esta função inicializa as matrizes de pontuação (score) e de rastreamento (trace).
    Ela cria matrizes com zeros, onde o número de colunas e linhas é determinado pelo comprimento das sequências S1 e S2.
    As pontuações na primeira coluna e na primeira linha são inicializadas de acordo com a penalidade de espaço (score_space).
    '''


def iniciar_matrizes(S1, S2, score_space):
    ncols, nlins = len(S1), len(S2)

    score = [[0 for _ in range(ncols)] for _ in range(nlins)]
    trace = [['E' if C == 0 else 'C' for C, _ in enumerate(S1)] for _ in range(nlins)]

    for L in range(nlins):
        score[L][0] = L * score_space

    for C in range(ncols):
        score[0][C] = C * score_space

    return score, trace

    '''
    needleman_wunsch: Esta é a função principal que implementa o algoritmo de Needleman-Wunsch.
    Ela chama a função iniciar_matrizes para criar as matrizes e, em seguida, preenche-as usando programação dinâmica.
    O algoritmo percorre todas as posições na matriz de pontuações, calcula as pontuações para os movimentos diagonais, para a esquerda e para cima, escolhe o máximo dessas opções e armazena na matriz de pontuações (score).
    A direção do movimento escolhido é armazenada na matriz de rastreamento (trace).
    Por fim, ela retorna o valor máximo na última posição da matriz de pontuações e chama a função reconstroi para obter o alinhamento.
    '''

def needleman_wunsch(S1, S2, score_space, score_subst):
    S2 = '-' + S2
    S1 = '-' + S1

    score, trace = iniciar_matrizes(S1, S2, score_space)

    for L, X2 in enumerate(S2):
        for C, X1 in enumerate(S1):
            if L > 0 and C > 0:
                diag = score[L - 1][C - 1] + score_subst(X1, X2, score_space)
                esq  = score[L][C - 1] + score_space
                cima = score[L - 1][C] + score_space

                escolhas = [diag, esq, cima]
                direcoes = "DEC"

                valor = max(escolhas)
                trace[L][C] = direcoes[escolhas.index(valor)]
                score[L][C] = valor

    return score[-1][-1], reconstroi(S1, S2, trace)

    '''
    reconstroi: Esta função recebe as sequências S1 e S2 e a matriz de rastreamento trace.
    Ela reconstrói o alinhamento seguindo o caminho armazenado em trace e retorna as sequências alinhadas A1 e A2.
    '''

def reconstroi(S1, S2, trace):
    A1, A2 = '', ''
    L, C = len(S2) - 1, len(S1) - 1

    while trace[L][C] != 'E':
        if trace[L][C] == 'D':
            A1, A2, L, C = S1[C] + A1, S2[L] + A2, L - 1, C - 1
        elif trace[L][C] == 'C':
            A1, A2, L = '-' + A1, S2[L] + A2, L - 1
        elif trace[L][C] == 'E':
            A1, A2, C = S1[C] + A1, '-' + A2, C - 1

    return A1, A2

    '''
    Finalmente, o código executa o exemplo com as sequências "x1" e "x2", penalidade de espaço igual a g e a função `score_subst
    '''

resultado, alinhamento = needleman_wunsch("x1", "x2", g, score_subst)
print("Resultado:", resultado)
print("Alinhamento:", alinhamento)
